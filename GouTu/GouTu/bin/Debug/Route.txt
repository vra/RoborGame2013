


#define max 44


 volatile float map[44][44];  
 volatile int p[44][44];        
 const int position[44][2]={0,0,9,0, 16,0, 23,0, 29,0, 36,0, 43,0, 49,0, 9,4, 23,4, 29,4, 43,4, 49,4, 9,10, 23,10, 29,10, 43,10, 49,10, 9,16, 23,16, 29,16, 43,16, 49,16, 12,19, 16,19, 23,19, 29,19, 36,19, 43,19, 49,19, 12,25, 16,25, 23,25, 29,25, 36,25, 43,25, 49,25, 9,19, 9,25, 4,25};
 
void createmap(void)
{
    int i,j;
    for(i=0;i<44;i++)
    {
        for(j=0;j<44;j++)
        {
            map[i][j]=99;
        }
    }
     map[0][1]=9;map[1][0]=9;map[1][2]=7;map[1][8]=4;map[2][1]=7;
     map[2][3]=7;map[3][2]=7;map[3][9]=4;map[3][4]=6;
     map[4][3]=6;map[4][10]=4;map[4][5]=7;map[5][4]=7;
     map[5][6]=7;map[6][5]=7;map[6][11]=4;map[6][7]=6;
     map[7][6]=6;map[7][12]=4;map[8][1]=4;map[8][13]=6;
     map[9][3]=4;map[9][10]=6;map[9][14]=6;map[10][4]=4;
     map[10][9]=6;map[10][15]=6;map[11][6]=4;map[11][12]=6;
     map[11][16]=6;map[12][11]=6;map[12][7]=4;map[12][17]=6;
     map[13][8]=6;map[13][18]=6;map[14][9]=6;map[14][19]=6;map[14][15]=6;
     map[15][14]=6;map[15][10]=6;map[15][20]=6;map[16][11]=6;map[16][21]=6;
     map[16][17]=6;map[18][13]=6;map[18][37]=3;map[19][20]=6;map[19][14]=6;
     map[19][25]=3;map[20][15]=6;map[20][19]=6;map[20][26]=3;map[21][16]=6;
     map[21][22]=6;map[21][27]=3;map[22][21]=6;map[22][17]=6;map[22][28]=3;
     map[37][18]=3;map[37][23]=3;map[37][38]=6;map[23][37]=3;map[23][30]=6;
     map[23][24]=4;map[24][23]=4;map[24][31]=6;map[24][25]=7;map[25][24]=7;
     map[25][19]=3;map[25][32]=6;map[25][26]=6;map[26][20]=3;map[26][25]=6;
     map[26][33]=6;map[26][27]=7;map[27][26]=7;map[27][34]=6;map[27][28]=7;
     map[28][27]=7;map[28][21]=3;map[28][35]=6;map[28][29]=6;map[29][28]=6;
     map[29][22]=3;map[29][36]=6;map[38][37]=6;map[38][30]=3;map[30][23]=6;
     map[30][31]=4;map[31][30]=4;map[31][24]=6;map[31][32]=7;map[32][31]=7;
     map[32][25]=6;map[32][33]=6;map[33][32]=6;map[33][26]=6;map[33][34]=7;
     map[34][33]=7;map[34][27]=6;map[34][35]=7;map[35][34]=7;map[35][36]=6;
     map[35][28]=6;map[36][35]=6;map[36][29]=6;map[38][37]=6;map[38][30]=3;
     map[39][40]=6;map[39][38]=4;map[40][39]=6;map[40][37]=4;
}
 //若探测到障碍物，则将障碍物所在路封锁
void createnode(int lastnote,int nextnote,int count)//功能：在两点之间设置障碍物标志。lastnote是
{
    int i = 0;
    for(i=0;i<=(41+count);i++)
    {
        map[i][(41+count)]=99;
        map[41+count][i]=99;
    }
    map[lastnote][nextnote]=99;  
}
void createnode1(int node)
{
    int i = 0;
     for(i=0;i<=41;i++)
     {
        map[i][node]=99;
        map[node][i]=99;
     }   
}
 //寻找较优路径，并将中途节点号存入p[目标节点编号][0:i-1], i为所需经过的节点个数
void dijkstra(int num0)//num0为起始点编号
{   
    int s[44]={0};
    float d[44];
    int i,j,k,w;
    float min;
    for(i=0;i<44;i++)
    {
        d[i]=0;
    }
    for(i=0;i<44;i++){
       for(j=0;j<44;j++)
       {
           p[i][j]=0;
       }
    } 
    for (i=1;i<max;i++)
    {
        d[i]=map[num0][i];
        if (d[i]!=99)
        {
            p[i][0]=num0;
            p[i][1]=i;
            p[i][2]=-1;
        }
    }

    s[num0]=1;
    d[num0]=0;

    for (i=1;i<max;i++)
    {
        min=99;
        for (j=1;j<max;j++)
        {
            if ((!s[j])&&(d[j]<min))
            {
                min=d[j];
                k=j;
            }
        }
        s[k]=1;
        for (j=0;j<max;j++)
        {
            if ((!s[j])&&(d[k]+map[k][j]<d[j]))
            {
                d[j]=d[k]+map[k][j];
                for (w=0;p[k][w]!=(-1);w++)
                {
                    p[j][w]=p[k][w];
                }
                p[j][w]=j;
                p[j][w+1]=(-1);
            }
        }
    }
}


